# Envoy Gateway Example Extension Service

This is an example of an extension service to Envoy Gateway. It uses Envoy Gateway's extensions API
to add support for a new custom type (`GlobalLuaScript`). The service listens for the xDS resource modification
hooks from Envoy Gateway and is then able to make any modifications to the xDS generated by Envoy Gateway.

This is a fairly barebones project and does not come with additional features that you will likely want to add to get an extension production-ready such as
metrics and tracing. Look through the code for the `TODO:` comments for areas you should modify. You are free to use this example as a base to build from, or
as a reference to see how extensions work if you want to use a different approach for your project.

## Who is this for?

This example project is for anyone who wants to use it either as a reference or as a base for building Envoy Gateway Extensions. Envoy Gateway extensions are targeted
at vendors that want to build products/solutions on top of Envoy Gateway. The lift for setting an Extension up is rather high, but this project should provide all the building blocks you
need to get started. One of the main use cases for extensions is to introduce custom resources not native to Envoy Gateway, and have controller(s) setup within the extension to watch
those resources and convert them into Envoy config. **If you are running Envoy Gateway and just want to have total control over the Envoy config to suit your own needs, you are probably going to be better served by using Envoy Gateways [Envoy Patch Policy][] resources

**NOTE:** Right now Envoy Gateway only supports using a single extension

## Deploying the Demo Service

1. Apply the CRDs from the `crds/generated` directory to your Kubernetes cluster. This extension introduces the example `GlobalLuaScript` custom resource
and will modify Envoy Gateway's xDS to use these `GlobalLuaScripts` on all requests.

2. Try applying an example `GlobalLuaScript`

   ```yaml
   kubectl apply -f -<<EOF
   ---
   apiVersion: exampleorg.io/v1
   kind:  GlobalLuaScript
   metadata:
     name:  example
   spec:
     lua: |
       function envoy_on_response(response_handle)
         response_handle:headers():add("Lua-Script-Enabled", "Processed")
       end
   EOF
   ```

3. Install the following RBAC so that the service has permission to watch and update our `GlobalLuaScript` resources

   ```yaml
   kubectl apply -f -<<EOF
   ---
   apiVersion: v1
   kind: ServiceAccount
   metadata:
     name: eg-example-extension
     namespace: default
   ---
   apiVersion: rbac.authorization.k8s.io/v1
   kind: ClusterRole
   metadata:
     name: eg-example-extension
   rules:
   - apiGroups: ["exampleorg.io"]
     resources: ["globalluascripts", "globalluascripts/status"]
     verbs: ["get", "list", "watch", "update", "delete"]
   ---
   apiVersion: rbac.authorization.k8s.io/v1
   kind: ClusterRoleBinding
   metadata:
     name: eg-example-extension-binding
   subjects:
   - kind: ServiceAccount
     name: eg-example-extension
     namespace: default
   roleRef:
     kind: ClusterRole
     name: eg-example-extension
     apiGroup: rbac.authorization.k8s.io
   EOF
   ```

4. Install the Deployment below using the pre-built image. Or build your own image and swap it out

   ```yaml
   kubectl apply -f -<<EOF
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: eg-example-extension
     namespace: default
     labels:
       app: eg-example-extension
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: eg-example-extension
     template:
       metadata:
         labels:
           app: eg-example-extension
         annotations:
           kubectl.kubernetes.io/default-container: eg-example-extension
       spec:
         securityContext:
           runAsNonRoot: true
         containers:
         - name: eg-example-extension
           image: alicewasko/extension-service:8cbb9de6
           ports:
           - name: xds-hooks
             containerPort: 9000
           - name: metrics
             containerPort: 8080
           - name: health-probes
             containerPort: 8081
           livenessProbe:
             failureThreshold: 3
             initialDelaySeconds: 30
             periodSeconds: 20
             successThreshold: 1
             timeoutSeconds: 1
             httpGet:
               path: /healthz
               port: 8081
           readinessProbe:
             failureThreshold: 3
             initialDelaySeconds: 30
             periodSeconds: 20
             successThreshold: 1
             timeoutSeconds: 1
             httpGet:
               path: /readyz
               port: 8081
           securityContext:
             allowPrivilegeEscalation: false
             capabilities:
               drop:
               - "ALL"
           resources:
             limits:
               cpu: 500m
               memory: 128Mi
             requests:
               cpu: 10m
               memory: 64Mi
         serviceAccount: eg-example-extension
         terminationGracePeriodSeconds: 10
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: eg-example-extension
     namespace: default
     labels:
       app: eg-example-extension
   spec:
     ports: 
     - name: xds-hooks
       port: 9000
       targetPort: 9000
     - name: metrics
       port: 8080
       targetPort: 8080
     - name: health
       port: 8081
       targetPort: 8081
     selector:
       app: eg-example-extension
   EOF
   ```

5. Wait for the deployment to be ready

   ```bash
   kubectl wait --timeout=5m deployment/eg-example-extension --for=condition=Available
   ```

6. Configure Envoy Gateway

   Using the following config as an example, edit your existing Envoy Gateway configmap and add the config to the `EnvoyGateway` resource section like seen below.
   This does a few things. First, it tells Envoy Gateway how to talk to our extension service. Next, it tells Envoy Gateway about our custom resources so that Envoy Gateway
   can watch them and reconfigure when they change. Finally, it tells Envoy Gateway which extensions API hooks this service wants to subscribe to. For this demo, we only need the
   ability to inject new HTTP filters into a listener, so we can omit the other hooks.

   ```yaml
   ---
   apiVersion: v1
   kind: ConfigMap
   metadata:
     annotations:
       meta.helm.sh/release-name: eg
       meta.helm.sh/release-namespace: envoy-gateway-system
     labels:
       app.kubernetes.io/instance: eg
       app.kubernetes.io/managed-by: Helm
       app.kubernetes.io/name: gateway-helm
       app.kubernetes.io/version: v1.0.0
       helm.sh/chart: gateway-helm-v1.0.0
     name: envoy-gateway-config
     namespace: envoy-gateway-system
   data:
     envoy-gateway.yaml: |
       apiVersion: gateway.envoyproxy.io/v1alpha1
       kind: EnvoyGateway
       gateway:
         controllerName: gateway.envoyproxy.io/gatewayclass-controller
       logging:
         level:
           default: info
       provider:
         type: Kubernetes
       extensionManager:
         resources:
         - group: exampleorg.io
           version: v1
           kind: GlobalLuaScript
         service:
           host: eg-example-extension.default
           port: 9000
         hooks:
           xdsTranslator:
             post:
             - "HTTPListener" # We only need this one hook for the demo
   ```

7. Restart Envoy Gateway

   After you edit the `EnvoyGateway` `ConfigMap` and have your extension service deployed, you will need to restart Envoy Gateway since it only reads that `ConfigMap` at startup.

8. Check the logs

   If you check the logs for the extension service pod, you should see that the controller is picking up our custom resources, we're getting xDS hooks requests from Envoy Gateway to modify
   the HTTP Listeners and we're injecting our lua filters into the HTTP Listeners.

   ```bash
   k logs eg-example-extension-6db8f55c44-d8cg4  
   
   4:15AM INF starting example Envoy Gateway extension service version: 0.6.0-dev built for linux/amd64...
   4:15AM INF starting xds hooks server address=0.0.0.0:9000
   4:15AM INF Reconciling GlobalLuaScript={"name":"example","namespace":"default"} controller=globalluascript controllerGroup=exampleorg.io controllerKind=GlobalLuaScript name=example namespace=default reconcileID=5fb7baf7-0825-4535-a8d2-368908025073
   4:15AM INF reconcile triggered by GlobalLuaScript name=example namespace=default
   4:15AM INF Reconcile successful GlobalLuaScript={"name":"example","namespace":"default"} controller=globalluascript controllerGroup=exampleorg.io controllerKind=GlobalLuaScript name=example namespace=default reconcileID=5fb7baf7-0825-4535-a8d2-368908025073
   4:16AM INF handling xDS HTTP Listener modification request from Envoy Gateway
   4:16AM INF injecting http lua filter for exampleorg.io.GlobalLuaFilter-default.example
   4:16AM INF filters to be set for listener: {"number": 2} {"content": [name:"exampleorg.io.GlobalLuaFilter-default.example"  typed_config:{[type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua]:{inline_code:"function envoy_on_response(response_handle)\n  response_handle:headers():add(\"Lua-Script-Enabled\", \"Processed\")\nend\n"}} name:"envoy.filters.http.router"  typed_config:{type_url:"type.googleapis.com/envoy.extensions.filters.http.router.v3.Router"  value:" \x01"}]}
   ```

9. Make some requests to a service and you should see that the `Lua-Script-Enabled` response header being added

## Building The Service

1. Set `REGISTRY` in `./make-targets/build.mk` to a registry name you want to use with your dockerhub account (or other registry of your choice)

   Note that it will use the environment variable `REGISTRY` first if that is set

2. Run `make` to build all the binaries, multi-arch docker builds, and push them to the registry you set above.

3. If you just want to build the binaries run `make binaries`

4. If you just want to push new docker images run `make images`

5. `make generate` will generate the Kubernetes custom resources defined in `./api`

## Repo Overview

You can run `make help` for an overview of the available make targets and refer to `./make-targets/README.md` for an overview of the simple make-based build system

- `./make-targets` contains makefile targets for the build system
- each subdirectory in `./cmd` gets built into a binary. There should be a directory for the name of the binary and it should only contain a `main.go` file.
- All of the core packages are in `./internal`.
- `./api` defines the Kubernetes custom resources
- `./docker` contains subdirectories that should match up with the subdirectories in `./cmd` each of these matches with a binary and gets built into a docker image.
- `./crds/generated` contains pre-generated CRDs. If you make any changes to the CRDs, you'll want to re-generate these
- `./dist` will be created when you run a build and it will contain the binaries
- `./goreleaser` contains config for all the binaries that are being built along with the os/arch

[Envoy Patch Policy]: https://gateway.envoyproxy.io/v1.0.0/user/extensibility/envoy-patch-policy/
